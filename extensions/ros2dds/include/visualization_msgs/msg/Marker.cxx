// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file Marker.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "Marker.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define geometry_msgs_msg_Vector3_max_cdr_typesize 24ULL;
#define builtin_interfaces_msg_Time_max_cdr_typesize 8ULL;
#define visualization_msgs_msg_MeshFile_max_cdr_typesize 364ULL;
#define geometry_msgs_msg_Pose_max_cdr_typesize 56ULL;
#define visualization_msgs_msg_Marker_max_cdr_typesize 7241ULL;
#define builtin_interfaces_msg_Duration_max_cdr_typesize 8ULL;
#define visualization_msgs_msg_UVCoordinate_max_cdr_typesize 8ULL;
#define geometry_msgs_msg_Point_max_cdr_typesize 24ULL;
#define std_msgs_msg_ColorRGBA_max_cdr_typesize 16ULL;
#define geometry_msgs_msg_Quaternion_max_cdr_typesize 32ULL;
#define std_msgs_msg_Header_max_cdr_typesize 268ULL;
#define sensor_msgs_msg_CompressedImage_max_cdr_typesize 632ULL;
#define geometry_msgs_msg_Vector3_max_key_cdr_typesize 0ULL;
#define builtin_interfaces_msg_Time_max_key_cdr_typesize 0ULL;
#define visualization_msgs_msg_MeshFile_max_key_cdr_typesize 0ULL;
#define geometry_msgs_msg_Pose_max_key_cdr_typesize 0ULL;
#define visualization_msgs_msg_Marker_max_key_cdr_typesize 0ULL;
#define builtin_interfaces_msg_Duration_max_key_cdr_typesize 0ULL;
#define visualization_msgs_msg_UVCoordinate_max_key_cdr_typesize 0ULL;
#define geometry_msgs_msg_Point_max_key_cdr_typesize 0ULL;
#define std_msgs_msg_ColorRGBA_max_key_cdr_typesize 0ULL;
#define geometry_msgs_msg_Quaternion_max_key_cdr_typesize 0ULL;
#define std_msgs_msg_Header_max_key_cdr_typesize 0ULL;
#define sensor_msgs_msg_CompressedImage_max_key_cdr_typesize 0ULL;


















visualization_msgs::msg::Marker::Marker()
{
    // std_msgs::msg::Header m_header

    // string m_ns
    m_ns ="";
    // long m_id
    m_id = 0;
    // long m_type
    m_type = 0;
    // long m_action
    m_action = 0;
    // geometry_msgs::msg::Pose m_pose

    // geometry_msgs::msg::Vector3 m_scale

    // std_msgs::msg::ColorRGBA m_color

    // builtin_interfaces::msg::Duration m_lifetime

    // boolean m_frame_locked
    m_frame_locked = false;
    // sequence<geometry_msgs::msg::Point> m_points

    // sequence<std_msgs::msg::ColorRGBA> m_colors

    // string m_texture_resource
    m_texture_resource ="";
    // sensor_msgs::msg::CompressedImage m_texture

    // sequence<visualization_msgs::msg::UVCoordinate> m_uv_coordinates

    // string m_text
    m_text ="";
    // string m_mesh_resource
    m_mesh_resource ="";
    // visualization_msgs::msg::MeshFile m_mesh_file

    // boolean m_mesh_use_embedded_materials
    m_mesh_use_embedded_materials = false;

}

visualization_msgs::msg::Marker::~Marker()
{



















}

visualization_msgs::msg::Marker::Marker(
        const Marker& x)
{
    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = x.m_pose;
    m_scale = x.m_scale;
    m_color = x.m_color;
    m_lifetime = x.m_lifetime;
    m_frame_locked = x.m_frame_locked;
    m_points = x.m_points;
    m_colors = x.m_colors;
    m_texture_resource = x.m_texture_resource;
    m_texture = x.m_texture;
    m_uv_coordinates = x.m_uv_coordinates;
    m_text = x.m_text;
    m_mesh_resource = x.m_mesh_resource;
    m_mesh_file = x.m_mesh_file;
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;
}

visualization_msgs::msg::Marker::Marker(
        Marker&& x) noexcept 
{
    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = std::move(x.m_pose);
    m_scale = std::move(x.m_scale);
    m_color = std::move(x.m_color);
    m_lifetime = std::move(x.m_lifetime);
    m_frame_locked = x.m_frame_locked;
    m_points = std::move(x.m_points);
    m_colors = std::move(x.m_colors);
    m_texture_resource = std::move(x.m_texture_resource);
    m_texture = std::move(x.m_texture);
    m_uv_coordinates = std::move(x.m_uv_coordinates);
    m_text = std::move(x.m_text);
    m_mesh_resource = std::move(x.m_mesh_resource);
    m_mesh_file = std::move(x.m_mesh_file);
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;
}

visualization_msgs::msg::Marker& visualization_msgs::msg::Marker::operator =(
        const Marker& x)
{

    m_header = x.m_header;
    m_ns = x.m_ns;
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = x.m_pose;
    m_scale = x.m_scale;
    m_color = x.m_color;
    m_lifetime = x.m_lifetime;
    m_frame_locked = x.m_frame_locked;
    m_points = x.m_points;
    m_colors = x.m_colors;
    m_texture_resource = x.m_texture_resource;
    m_texture = x.m_texture;
    m_uv_coordinates = x.m_uv_coordinates;
    m_text = x.m_text;
    m_mesh_resource = x.m_mesh_resource;
    m_mesh_file = x.m_mesh_file;
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;

    return *this;
}

visualization_msgs::msg::Marker& visualization_msgs::msg::Marker::operator =(
        Marker&& x) noexcept
{

    m_header = std::move(x.m_header);
    m_ns = std::move(x.m_ns);
    m_id = x.m_id;
    m_type = x.m_type;
    m_action = x.m_action;
    m_pose = std::move(x.m_pose);
    m_scale = std::move(x.m_scale);
    m_color = std::move(x.m_color);
    m_lifetime = std::move(x.m_lifetime);
    m_frame_locked = x.m_frame_locked;
    m_points = std::move(x.m_points);
    m_colors = std::move(x.m_colors);
    m_texture_resource = std::move(x.m_texture_resource);
    m_texture = std::move(x.m_texture);
    m_uv_coordinates = std::move(x.m_uv_coordinates);
    m_text = std::move(x.m_text);
    m_mesh_resource = std::move(x.m_mesh_resource);
    m_mesh_file = std::move(x.m_mesh_file);
    m_mesh_use_embedded_materials = x.m_mesh_use_embedded_materials;

    return *this;
}

bool visualization_msgs::msg::Marker::operator ==(
        const Marker& x) const
{

    return (m_header == x.m_header && m_ns == x.m_ns && m_id == x.m_id && m_type == x.m_type && m_action == x.m_action && m_pose == x.m_pose && m_scale == x.m_scale && m_color == x.m_color && m_lifetime == x.m_lifetime && m_frame_locked == x.m_frame_locked && m_points == x.m_points && m_colors == x.m_colors && m_texture_resource == x.m_texture_resource && m_texture == x.m_texture && m_uv_coordinates == x.m_uv_coordinates && m_text == x.m_text && m_mesh_resource == x.m_mesh_resource && m_mesh_file == x.m_mesh_file && m_mesh_use_embedded_materials == x.m_mesh_use_embedded_materials);
}

bool visualization_msgs::msg::Marker::operator !=(
        const Marker& x) const
{
    return !(*this == x);
}

size_t visualization_msgs::msg::Marker::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return visualization_msgs_msg_Marker_max_cdr_typesize;
}

size_t visualization_msgs::msg::Marker::getCdrSerializedSize(
        const visualization_msgs::msg::Marker& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += std_msgs::msg::Header::getCdrSerializedSize(data.header(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.ns().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += geometry_msgs::msg::Pose::getCdrSerializedSize(data.pose(), current_alignment);
    current_alignment += geometry_msgs::msg::Vector3::getCdrSerializedSize(data.scale(), current_alignment);
    current_alignment += std_msgs::msg::ColorRGBA::getCdrSerializedSize(data.color(), current_alignment);
    current_alignment += builtin_interfaces::msg::Duration::getCdrSerializedSize(data.lifetime(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.points().size(); ++a)
    {
        current_alignment += geometry_msgs::msg::Point::getCdrSerializedSize(data.points().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.colors().size(); ++a)
    {
        current_alignment += std_msgs::msg::ColorRGBA::getCdrSerializedSize(data.colors().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.texture_resource().size() + 1;

    current_alignment += sensor_msgs::msg::CompressedImage::getCdrSerializedSize(data.texture(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.uv_coordinates().size(); ++a)
    {
        current_alignment += visualization_msgs::msg::UVCoordinate::getCdrSerializedSize(data.uv_coordinates().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.text().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.mesh_resource().size() + 1;

    current_alignment += visualization_msgs::msg::MeshFile::getCdrSerializedSize(data.mesh_file(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void visualization_msgs::msg::Marker::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_header;
    scdr << m_ns.c_str();
    scdr << m_id;
    scdr << m_type;
    scdr << m_action;
    scdr << m_pose;
    scdr << m_scale;
    scdr << m_color;
    scdr << m_lifetime;
    scdr << m_frame_locked;
    scdr << m_points;
    scdr << m_colors;
    scdr << m_texture_resource.c_str();
    scdr << m_texture;
    scdr << m_uv_coordinates;
    scdr << m_text.c_str();
    scdr << m_mesh_resource.c_str();
    scdr << m_mesh_file;
    scdr << m_mesh_use_embedded_materials;

}

void visualization_msgs::msg::Marker::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_header;
    dcdr >> m_ns;
    dcdr >> m_id;
    dcdr >> m_type;
    dcdr >> m_action;
    dcdr >> m_pose;
    dcdr >> m_scale;
    dcdr >> m_color;
    dcdr >> m_lifetime;
    dcdr >> m_frame_locked;
    dcdr >> m_points;
    dcdr >> m_colors;
    dcdr >> m_texture_resource;
    dcdr >> m_texture;
    dcdr >> m_uv_coordinates;
    dcdr >> m_text;
    dcdr >> m_mesh_resource;
    dcdr >> m_mesh_file;
    dcdr >> m_mesh_use_embedded_materials;
}

/*!
 * @brief This function copies the value in member header
 * @param _header New value to be copied in member header
 */
void visualization_msgs::msg::Marker::header(
        const std_msgs::msg::Header& _header)
{
    m_header = _header;
}

/*!
 * @brief This function moves the value in member header
 * @param _header New value to be moved in member header
 */
void visualization_msgs::msg::Marker::header(
        std_msgs::msg::Header&& _header)
{
    m_header = std::move(_header);
}

/*!
 * @brief This function returns a constant reference to member header
 * @return Constant reference to member header
 */
const std_msgs::msg::Header& visualization_msgs::msg::Marker::header() const
{
    return m_header;
}

/*!
 * @brief This function returns a reference to member header
 * @return Reference to member header
 */
std_msgs::msg::Header& visualization_msgs::msg::Marker::header()
{
    return m_header;
}
/*!
 * @brief This function copies the value in member ns
 * @param _ns New value to be copied in member ns
 */
void visualization_msgs::msg::Marker::ns(
        const std::string& _ns)
{
    m_ns = _ns;
}

/*!
 * @brief This function moves the value in member ns
 * @param _ns New value to be moved in member ns
 */
void visualization_msgs::msg::Marker::ns(
        std::string&& _ns)
{
    m_ns = std::move(_ns);
}

/*!
 * @brief This function returns a constant reference to member ns
 * @return Constant reference to member ns
 */
const std::string& visualization_msgs::msg::Marker::ns() const
{
    return m_ns;
}

/*!
 * @brief This function returns a reference to member ns
 * @return Reference to member ns
 */
std::string& visualization_msgs::msg::Marker::ns()
{
    return m_ns;
}
/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void visualization_msgs::msg::Marker::id(
        int32_t _id)
{
    m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t visualization_msgs::msg::Marker::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& visualization_msgs::msg::Marker::id()
{
    return m_id;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void visualization_msgs::msg::Marker::type(
        int32_t _type)
{
    m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
int32_t visualization_msgs::msg::Marker::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
int32_t& visualization_msgs::msg::Marker::type()
{
    return m_type;
}

/*!
 * @brief This function sets a value in member action
 * @param _action New value for member action
 */
void visualization_msgs::msg::Marker::action(
        int32_t _action)
{
    m_action = _action;
}

/*!
 * @brief This function returns the value of member action
 * @return Value of member action
 */
int32_t visualization_msgs::msg::Marker::action() const
{
    return m_action;
}

/*!
 * @brief This function returns a reference to member action
 * @return Reference to member action
 */
int32_t& visualization_msgs::msg::Marker::action()
{
    return m_action;
}

/*!
 * @brief This function copies the value in member pose
 * @param _pose New value to be copied in member pose
 */
void visualization_msgs::msg::Marker::pose(
        const geometry_msgs::msg::Pose& _pose)
{
    m_pose = _pose;
}

/*!
 * @brief This function moves the value in member pose
 * @param _pose New value to be moved in member pose
 */
void visualization_msgs::msg::Marker::pose(
        geometry_msgs::msg::Pose&& _pose)
{
    m_pose = std::move(_pose);
}

/*!
 * @brief This function returns a constant reference to member pose
 * @return Constant reference to member pose
 */
const geometry_msgs::msg::Pose& visualization_msgs::msg::Marker::pose() const
{
    return m_pose;
}

/*!
 * @brief This function returns a reference to member pose
 * @return Reference to member pose
 */
geometry_msgs::msg::Pose& visualization_msgs::msg::Marker::pose()
{
    return m_pose;
}
/*!
 * @brief This function copies the value in member scale
 * @param _scale New value to be copied in member scale
 */
void visualization_msgs::msg::Marker::scale(
        const geometry_msgs::msg::Vector3& _scale)
{
    m_scale = _scale;
}

/*!
 * @brief This function moves the value in member scale
 * @param _scale New value to be moved in member scale
 */
void visualization_msgs::msg::Marker::scale(
        geometry_msgs::msg::Vector3&& _scale)
{
    m_scale = std::move(_scale);
}

/*!
 * @brief This function returns a constant reference to member scale
 * @return Constant reference to member scale
 */
const geometry_msgs::msg::Vector3& visualization_msgs::msg::Marker::scale() const
{
    return m_scale;
}

/*!
 * @brief This function returns a reference to member scale
 * @return Reference to member scale
 */
geometry_msgs::msg::Vector3& visualization_msgs::msg::Marker::scale()
{
    return m_scale;
}
/*!
 * @brief This function copies the value in member color
 * @param _color New value to be copied in member color
 */
void visualization_msgs::msg::Marker::color(
        const std_msgs::msg::ColorRGBA& _color)
{
    m_color = _color;
}

/*!
 * @brief This function moves the value in member color
 * @param _color New value to be moved in member color
 */
void visualization_msgs::msg::Marker::color(
        std_msgs::msg::ColorRGBA&& _color)
{
    m_color = std::move(_color);
}

/*!
 * @brief This function returns a constant reference to member color
 * @return Constant reference to member color
 */
const std_msgs::msg::ColorRGBA& visualization_msgs::msg::Marker::color() const
{
    return m_color;
}

/*!
 * @brief This function returns a reference to member color
 * @return Reference to member color
 */
std_msgs::msg::ColorRGBA& visualization_msgs::msg::Marker::color()
{
    return m_color;
}
/*!
 * @brief This function copies the value in member lifetime
 * @param _lifetime New value to be copied in member lifetime
 */
void visualization_msgs::msg::Marker::lifetime(
        const builtin_interfaces::msg::Duration& _lifetime)
{
    m_lifetime = _lifetime;
}

/*!
 * @brief This function moves the value in member lifetime
 * @param _lifetime New value to be moved in member lifetime
 */
void visualization_msgs::msg::Marker::lifetime(
        builtin_interfaces::msg::Duration&& _lifetime)
{
    m_lifetime = std::move(_lifetime);
}

/*!
 * @brief This function returns a constant reference to member lifetime
 * @return Constant reference to member lifetime
 */
const builtin_interfaces::msg::Duration& visualization_msgs::msg::Marker::lifetime() const
{
    return m_lifetime;
}

/*!
 * @brief This function returns a reference to member lifetime
 * @return Reference to member lifetime
 */
builtin_interfaces::msg::Duration& visualization_msgs::msg::Marker::lifetime()
{
    return m_lifetime;
}
/*!
 * @brief This function sets a value in member frame_locked
 * @param _frame_locked New value for member frame_locked
 */
void visualization_msgs::msg::Marker::frame_locked(
        bool _frame_locked)
{
    m_frame_locked = _frame_locked;
}

/*!
 * @brief This function returns the value of member frame_locked
 * @return Value of member frame_locked
 */
bool visualization_msgs::msg::Marker::frame_locked() const
{
    return m_frame_locked;
}

/*!
 * @brief This function returns a reference to member frame_locked
 * @return Reference to member frame_locked
 */
bool& visualization_msgs::msg::Marker::frame_locked()
{
    return m_frame_locked;
}

/*!
 * @brief This function copies the value in member points
 * @param _points New value to be copied in member points
 */
void visualization_msgs::msg::Marker::points(
        const std::vector<geometry_msgs::msg::Point>& _points)
{
    m_points = _points;
}

/*!
 * @brief This function moves the value in member points
 * @param _points New value to be moved in member points
 */
void visualization_msgs::msg::Marker::points(
        std::vector<geometry_msgs::msg::Point>&& _points)
{
    m_points = std::move(_points);
}

/*!
 * @brief This function returns a constant reference to member points
 * @return Constant reference to member points
 */
const std::vector<geometry_msgs::msg::Point>& visualization_msgs::msg::Marker::points() const
{
    return m_points;
}

/*!
 * @brief This function returns a reference to member points
 * @return Reference to member points
 */
std::vector<geometry_msgs::msg::Point>& visualization_msgs::msg::Marker::points()
{
    return m_points;
}
/*!
 * @brief This function copies the value in member colors
 * @param _colors New value to be copied in member colors
 */
void visualization_msgs::msg::Marker::colors(
        const std::vector<std_msgs::msg::ColorRGBA>& _colors)
{
    m_colors = _colors;
}

/*!
 * @brief This function moves the value in member colors
 * @param _colors New value to be moved in member colors
 */
void visualization_msgs::msg::Marker::colors(
        std::vector<std_msgs::msg::ColorRGBA>&& _colors)
{
    m_colors = std::move(_colors);
}

/*!
 * @brief This function returns a constant reference to member colors
 * @return Constant reference to member colors
 */
const std::vector<std_msgs::msg::ColorRGBA>& visualization_msgs::msg::Marker::colors() const
{
    return m_colors;
}

/*!
 * @brief This function returns a reference to member colors
 * @return Reference to member colors
 */
std::vector<std_msgs::msg::ColorRGBA>& visualization_msgs::msg::Marker::colors()
{
    return m_colors;
}
/*!
 * @brief This function copies the value in member texture_resource
 * @param _texture_resource New value to be copied in member texture_resource
 */
void visualization_msgs::msg::Marker::texture_resource(
        const std::string& _texture_resource)
{
    m_texture_resource = _texture_resource;
}

/*!
 * @brief This function moves the value in member texture_resource
 * @param _texture_resource New value to be moved in member texture_resource
 */
void visualization_msgs::msg::Marker::texture_resource(
        std::string&& _texture_resource)
{
    m_texture_resource = std::move(_texture_resource);
}

/*!
 * @brief This function returns a constant reference to member texture_resource
 * @return Constant reference to member texture_resource
 */
const std::string& visualization_msgs::msg::Marker::texture_resource() const
{
    return m_texture_resource;
}

/*!
 * @brief This function returns a reference to member texture_resource
 * @return Reference to member texture_resource
 */
std::string& visualization_msgs::msg::Marker::texture_resource()
{
    return m_texture_resource;
}
/*!
 * @brief This function copies the value in member texture
 * @param _texture New value to be copied in member texture
 */
void visualization_msgs::msg::Marker::texture(
        const sensor_msgs::msg::CompressedImage& _texture)
{
    m_texture = _texture;
}

/*!
 * @brief This function moves the value in member texture
 * @param _texture New value to be moved in member texture
 */
void visualization_msgs::msg::Marker::texture(
        sensor_msgs::msg::CompressedImage&& _texture)
{
    m_texture = std::move(_texture);
}

/*!
 * @brief This function returns a constant reference to member texture
 * @return Constant reference to member texture
 */
const sensor_msgs::msg::CompressedImage& visualization_msgs::msg::Marker::texture() const
{
    return m_texture;
}

/*!
 * @brief This function returns a reference to member texture
 * @return Reference to member texture
 */
sensor_msgs::msg::CompressedImage& visualization_msgs::msg::Marker::texture()
{
    return m_texture;
}
/*!
 * @brief This function copies the value in member uv_coordinates
 * @param _uv_coordinates New value to be copied in member uv_coordinates
 */
void visualization_msgs::msg::Marker::uv_coordinates(
        const std::vector<visualization_msgs::msg::UVCoordinate>& _uv_coordinates)
{
    m_uv_coordinates = _uv_coordinates;
}

/*!
 * @brief This function moves the value in member uv_coordinates
 * @param _uv_coordinates New value to be moved in member uv_coordinates
 */
void visualization_msgs::msg::Marker::uv_coordinates(
        std::vector<visualization_msgs::msg::UVCoordinate>&& _uv_coordinates)
{
    m_uv_coordinates = std::move(_uv_coordinates);
}

/*!
 * @brief This function returns a constant reference to member uv_coordinates
 * @return Constant reference to member uv_coordinates
 */
const std::vector<visualization_msgs::msg::UVCoordinate>& visualization_msgs::msg::Marker::uv_coordinates() const
{
    return m_uv_coordinates;
}

/*!
 * @brief This function returns a reference to member uv_coordinates
 * @return Reference to member uv_coordinates
 */
std::vector<visualization_msgs::msg::UVCoordinate>& visualization_msgs::msg::Marker::uv_coordinates()
{
    return m_uv_coordinates;
}
/*!
 * @brief This function copies the value in member text
 * @param _text New value to be copied in member text
 */
void visualization_msgs::msg::Marker::text(
        const std::string& _text)
{
    m_text = _text;
}

/*!
 * @brief This function moves the value in member text
 * @param _text New value to be moved in member text
 */
void visualization_msgs::msg::Marker::text(
        std::string&& _text)
{
    m_text = std::move(_text);
}

/*!
 * @brief This function returns a constant reference to member text
 * @return Constant reference to member text
 */
const std::string& visualization_msgs::msg::Marker::text() const
{
    return m_text;
}

/*!
 * @brief This function returns a reference to member text
 * @return Reference to member text
 */
std::string& visualization_msgs::msg::Marker::text()
{
    return m_text;
}
/*!
 * @brief This function copies the value in member mesh_resource
 * @param _mesh_resource New value to be copied in member mesh_resource
 */
void visualization_msgs::msg::Marker::mesh_resource(
        const std::string& _mesh_resource)
{
    m_mesh_resource = _mesh_resource;
}

/*!
 * @brief This function moves the value in member mesh_resource
 * @param _mesh_resource New value to be moved in member mesh_resource
 */
void visualization_msgs::msg::Marker::mesh_resource(
        std::string&& _mesh_resource)
{
    m_mesh_resource = std::move(_mesh_resource);
}

/*!
 * @brief This function returns a constant reference to member mesh_resource
 * @return Constant reference to member mesh_resource
 */
const std::string& visualization_msgs::msg::Marker::mesh_resource() const
{
    return m_mesh_resource;
}

/*!
 * @brief This function returns a reference to member mesh_resource
 * @return Reference to member mesh_resource
 */
std::string& visualization_msgs::msg::Marker::mesh_resource()
{
    return m_mesh_resource;
}
/*!
 * @brief This function copies the value in member mesh_file
 * @param _mesh_file New value to be copied in member mesh_file
 */
void visualization_msgs::msg::Marker::mesh_file(
        const visualization_msgs::msg::MeshFile& _mesh_file)
{
    m_mesh_file = _mesh_file;
}

/*!
 * @brief This function moves the value in member mesh_file
 * @param _mesh_file New value to be moved in member mesh_file
 */
void visualization_msgs::msg::Marker::mesh_file(
        visualization_msgs::msg::MeshFile&& _mesh_file)
{
    m_mesh_file = std::move(_mesh_file);
}

/*!
 * @brief This function returns a constant reference to member mesh_file
 * @return Constant reference to member mesh_file
 */
const visualization_msgs::msg::MeshFile& visualization_msgs::msg::Marker::mesh_file() const
{
    return m_mesh_file;
}

/*!
 * @brief This function returns a reference to member mesh_file
 * @return Reference to member mesh_file
 */
visualization_msgs::msg::MeshFile& visualization_msgs::msg::Marker::mesh_file()
{
    return m_mesh_file;
}
/*!
 * @brief This function sets a value in member mesh_use_embedded_materials
 * @param _mesh_use_embedded_materials New value for member mesh_use_embedded_materials
 */
void visualization_msgs::msg::Marker::mesh_use_embedded_materials(
        bool _mesh_use_embedded_materials)
{
    m_mesh_use_embedded_materials = _mesh_use_embedded_materials;
}

/*!
 * @brief This function returns the value of member mesh_use_embedded_materials
 * @return Value of member mesh_use_embedded_materials
 */
bool visualization_msgs::msg::Marker::mesh_use_embedded_materials() const
{
    return m_mesh_use_embedded_materials;
}

/*!
 * @brief This function returns a reference to member mesh_use_embedded_materials
 * @return Reference to member mesh_use_embedded_materials
 */
bool& visualization_msgs::msg::Marker::mesh_use_embedded_materials()
{
    return m_mesh_use_embedded_materials;
}



size_t visualization_msgs::msg::Marker::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return visualization_msgs_msg_Marker_max_key_cdr_typesize;
}

bool visualization_msgs::msg::Marker::isKeyDefined()
{
    return false;
}

void visualization_msgs::msg::Marker::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}


